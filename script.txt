# Member 1 Introduction<br>
Good day, everyone. We are here to present our final project for CS 300-CS31S1: Automata Theory and Formal Languages.<br>
Throughout this course, we've studied the theoretical building blocks of computation.<br>
Our project aims to bring those concepts to life through two distinct programs: a 'Real-Life Application' program and an 'Implementation' program.<br>
For our real-life application, we built Program 1, which is a visual, interactive NFA editor.<br>
This tool allows anyone to graphically design a Nondeterministic Finite Automaton and then automatically convert it into an equivalent Deterministic Finite Automaton using the subset construction algorithm.<br>
For our implementation program, we created Program 2, a command-line tool that takes a DFA in a JSON format—like the one from Program 1—and uses Hopcroft's minimization algorithm to produce its most optimized, minimal-state equivalent.<br>
This combination allows us to visually design an automaton, like one for a text parser or a simple vending machine, and then use a core algorithm to make it as efficient as possible.<br>
To start our demo, I'll pass it over to Member 2 to demonstrate Program 1.<br>

# Member 2 Program 1: Visual NFA to DFA Converter Demo<br>
Thank you. I am now running Program 1.<br>
Okay, so here is our Visual NFA to DFA editor, which we built using Python and Tkinter.<br>
On the right, we have this character which acts as our state generator, and on the left is the main canvas where we will build our automaton.<br>
The UI also supports panning by dragging the canvas and zooming with the mouse wheel, which is very useful for building larger, more complex graphs.<br>
First, I will create four states to build a slightly more complex NFA.<br>
I'll drag the 'mouth' icon onto the canvas to create State 1... now State 2... State 3... and State 4.<br>
Next, I need to define the start and final states.<br>
I'll right-click on State 1 and select 'Set as Starting State'. You can see the entry arrow appears.<br>
For this demo, I'll set two final states: I'll right-click State 3 and 'Toggle Final State', and I'll also right-click State 4 and 'Toggle Final State'. You can see the inner circle indicating they are accepting states.<br>
Now, I'll add the transitions:<br>
* First, a transition from State 1 to State 2 on symbol 'a'.<br>
* I'll also add an epsilon transition from State 1 directly to State 3. I just type 'e' in the symbol dialog.<br>
This already makes it a nondeterministic machine, as State 1 has a path on 'a' and a path on 'epsilon'.<br>
* Now, from State 2, I'll add a self-loop on symbol 'b'.<br>
* And from State 2, I'll add another transition to State 4 on symbol 'a'.<br>
* Finally, from State 3, I'll add a transition to State 4 on symbol 'b'.<br>
So, we have a complete NFA. With this ready, I will now click the 'Convert to DFA' button.<br>
Instantly, the two tables at the bottom are populated.<br>
The NFA table on the left shows the transitions we just drew, including the 'ε' column.<br>
But the real result is the DFA table on the right. This shows the output of the subset construction algorithm.<br>
Our new start state is {1, 3}, which is the epsilon-closure of our original State 1.<br>
You can also see complex new states like {4} or {2} have been created, and the table is fully deterministic, with no empty cells.<br>
It also correctly identifies the dead state, Ø, for any undefined transitions.<br>
Finally, to pass this to the next part of our project, I'll save this machine.<br>
I'll click 'Export to .JSON'. This saves our new DFA as OUTPUT1.json.<br>
That concludes the demo for Program 1. Now, Member 3 will show you Program 2.<br>

# Member 3 Program 2: DFA Minimization Tool Demo<br>
Thanks. I am now in the terminal to run Program 2, our DFA Minimization tool.<br>
This program implements Hopcroft's algorithm, which is a very efficient method for minimizing DFAs.<br>
I'll run the script by typing python PROGRAM2.py.<br>
The program starts and asks for the path to the input DFA JSON file.<br>
I'll enter OUTPUT1.json, which Member 2 just exported from the visual editor.<br>
Okay, the script has run. You can see the step-by-step process in the terminal.<br>
1. It first completes the DFA by adding an internal 'dead state' for any missing transitions.<br>
2. Then, it removes any unreachable states—states that can't be reached from the start state.<br>
3. After that, it prints the 'Original DFA (Reachable)' table. This is our starting point before minimization.<br>
Then, the main algorithm runs. Hopcroft's algorithm works by initially partitioning all states into two groups—Final and Non-Final—and then it repeatedly refines those partitions by checking if states are "distinguishable" by any input symbol.<br>
Right below the original, it prints the final 'Minimized DFA' transition table.<br>
In this new table, any states that the algorithm found to be "indistinguishable" are merged into a single state, represented by a set.<br>
This new table represents the most efficient automaton—the one with the fewest possible states—that still accepts the exact same language as our original machine.<br>
Finally, the program asks if I want to save this minimized DFA to a new JSON file.<br>
I'll type 'y' for yes, and I'll name the file minimized.json.<br>
This completes the demo of Program 2. Now, I'll hand it over to Member 4 for the conclusion.<br>

# Member 4 Conclusion<br>
Thank you. To summarize our project, we have successfully demonstrated the complete workflow of designing and optimizing an automaton.<br>
Our Program 1, the 'real-life application', provides a visual, user-friendly interface to build complex NFAs and apply the subset construction algorithm to convert them into DFAs.<br>
Our Program 2, the 'implementation' program, takes that output and demonstrates a core optimization algorithm from our class, Hopcroft's minimization, to produce the most efficient DFA possible.<br>
Together, these programs cover the key theoretical concepts and practical applications of Automata Theory, from initial design to final optimization.<br>
On behalf of all our members, thank you for watching our presentation.<br>
